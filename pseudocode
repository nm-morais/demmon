

Messages:

- Join {}
- JoinReply {mChildren, mLevel, mParentLatency}
- JoinAsParent{mChildren, mLevel}
- JoinAsChildren{}

Constants

- GRAND_PARENT_LATENCY_INCREASE_THRESHOLD // represents how much additional latency is tolerated so that a joining node can join a position between a children and its parent   
- BOOTSTRAP_NODES

Join state:

- currLevelPeers // []Peer
- currLevelPeersDone // []Peer

- currJoinLevel // number
- myLatencies // map[Peer]Latency // my own latencies

- parents // map[Peer]Peer // holds the parents of each node
- children // map[Peer][]Peer // map holding a the children of a node
- parentLatencies // map[Peer]Latency // map of peer to the latencies

- possibleChildren // array of possible children of joining node
- possibleParent // array of possible children of joining node

Node state:

- parentLatency Latency
- parent {Peer, Latency}
- grandParent {Peer, Latency}
- children // []Peer
- level // int
- self // Peer

upon INIT:
    currJoinLevel = 1
    currLevelPeers = BOOTSTRAP_NODES
    for node in currLevelPeers:
        parent[node] = null
        send(Join{}, node)
    

upon receive(Join{}, sender):
    if level = 0 {
        send (JoinReply {children, level, -1}, sender)
        return
    }
    send (JoinReply{children , level, parentLatency}, sender)


upon receive(JoinReply{mChildren, mLevel, mParentLatency}, sender):

    if mLevel != currJoinLevel {
        return
    }

    myLatencies[sender] = measureLatency(sender)
    currLevelPeersDone.append(sender)
    children[peer] = mChildren
    parentLatencies[peer] = mParentLatency
    for child in mChildren {
        parent[child] = sender
    }

    if currLevelPeersDone.ContainsAll(currLevelPeers){

        // have contacted all nodes in this level
        lowestLatencyPeer  <- getLowestLatencyPeer(myLatencies, currLevelPeersDone)


        if myLatencies[parent[lowestLatencyPeer]] < myLatencies[lowestLatencyPeer]{
            // join level as children, as it is not advantageous to become children of existing nodes
            // should warn the children of the node ?
            send (JoinAsChildren{}, parent[lowestLatencyPeer])
            return
        }

        if parentLatencies[lowestLatencyPeer] + GRAND_PARENT_LATENCY_INCREASE_THRESHOLD > myLatencies[parents[lowestLatencyPeer]] + myLatencies[lowestLatencyPeer] {
            // i can be the parent of this peer because i have a low latency in between him and his parent
            // TODO check other peers in this level for the same condition 

            possibleChildren = [lowestLatencyPeer]
            possibleParent = parent[lowestLatencyPeer]
            for peer in currLevelPeersDone {
                if peer == lowestLatencyPeer {
                    continue
                }
                if parentLatencies[lowestLatencyPeer] + GRAND_PARENT_LATENCY_INCREASE_TOLERANCE > myLatencies[parents[lowestLatencyPeer]] + myLatencies[lowestLatencyPeer] {
                    possibleChildren.append(peer)
                }
            }

            for node in possibleChildren {
                sendMessage(JoinAsParent{possibleChildren, currJoinLevel}, node)
            }

            send (JoinAsChildren{}, parents[lowestLatencyPeer] )
            return
        }
        
        // base case,  explore the lowest latency nodes' children, because i have lower latency to him vs its parent
        if children[lowestLatencyPeer].isEmpty() {
            // cannot progress level, join as children
            send (JoinAsChildren{}, lowestLatencyPeer)
            return
        }

        currJoinLevel += 1
        currLevelPeers = children[lowestLatencyPeer]
        currLevelPeersDone = []
        for peer in currLevelPeers{
            send(Join{}, node)
        }

        return
    }

upon receive(JoinAsParent{mChildren, mLevel}, sender) : 
    for peerChild in mChildren {
        if children.contains(peerChild) {
            children.remove(peerChild)
        }
    }

    if sender != parent {
        parent = sender
        level = mLevel + 1
        for peer in children {
            send(UpdateParent{ parent ,self, level + 1})
        }
    }
}

upon receive (UpdateParent{mGrandParent, mParent, level}, sender) {
    grandParent = mGrandParent
    parent = mParent
    level = level
    for peer in children {
        send(UpdateParent{parent , self, level + 1})
    }
}

upon receive(JoinAsChildren{}, sender) : 
    children.append(sender)
}