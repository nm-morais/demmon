

Messages:

- Join {}
- JoinReply {mChildren, mLevel, mParentLatency }
- JoinLevel {mParent, mChildren}
- JoinLevelReply {accepted} // just an ack from the children

Constants

- PARENT_LATENCY_THRESHOLD Int
- GRAND_PARENT_LATENCY_INCREASE_TOLERANCE // represents how much additional latency is tolerated so that a joining node can join a position between a children and its parent   
- BOOTSTRAP_NODES

Join state:

- currLevelPeers // []Peer
- currLevelPeersDone // []Peer

- currJoinLevel // number
- myLatencies // map[Peer]Latency // my own latencies

- parents // map[Peer]Peer // holds the parents of each node
- children // map[Peer][]Peer // map holding a the children of a node
- parentLatencies // map[Peer]Latency // map of peer to the latencies

- possibleChildren // array of possible children of joining node
- possibleParent // array of possible children of joining node

Node state:

- parentLatency Latency
- parent {Peer, Latency}
- children // []Peer
- level // int
- self // Peer

upon INIT:
    currJoinLevel = 0
    currLevelPeers = BOOTSTRAP_NODES
    for node in currLevelPeers:
        parent[node] = null
        send(Join{}, node)
    

upon receive(Join{}, sender):
    if level = 0 {
        send (JoinReply {children, level, -1}, sender)
        return
    }
    send (JoinReply{children , level, parentLatency}, sender)


upon receive(JoinReply{mChildren, mLevel, mParentLatency}, sender):

    if mLevel != currJoinLevel {
        return
    }

    myLatencies[sender] = measureLatency(sender)
    currLevelPeersDone.append(sender)
    children[peer] = mChildren
    parentLatencies[peer] = mParentLatency
    for child in mChildren {
        parent[child] = sender
    }

    if currLevelPeersDone.ContainsAll(currLevelPeers){

        // have contacted all nodes in this level
        lowestLatencyPeer  <- getLowestLatencyPeer(myLatencies, currLevelPeers)

        if currJoinLevel == 0 {
            // keep going down the tree
            currLevelPeers = children[lowestLatencyPeer]
            currJoinLevel += 1
            currLevelPeersDone = []
            for peer in currLevelPeers{
                send(Join{}, node)
            }
            return
        }

        if myLatencies[lowestLatencyPeer] > PARENT_LATENCY_THRESHOLD{
            // join level
            // should warn the children of the node ?
            send (JoinLevel{parent[lowestLatencyPeer], []}, parent[lowestLatencyPeer])
            return
        }

        if parentLatencies[lowestLatencyPeer] + GRAND_PARENT_LATENCY_INCREASE_TOLERANCE > myLatencies[parents[lowestLatencyPeer]] + myLatencies[lowestLatencyPeer] {
            // i can be the parent of this peer because i have a low latency in between him and his parent
            // TODO check other peers in this level for the same condition 

            possibleChildren = [lowestLatencyPeer]
            possibleParent = parent[lowestLatencyPeer]
            for peer in currLevelPeersDone {
                if peer == lowestLatencyPeer {
                    continue
                }
                if parentLatencies[lowestLatencyPeer] + GRAND_PARENT_LATENCY_INCREASE_TOLERANCE > myLatencies[parents[lowestLatencyPeer]] + myLatencies[lowestLatencyPeer] {
                    possibleChildren.append(peer)
                }
            }
            for node in possibleChildren {
                sendMessage(JoinLevel{parent[lowestLatencyPeer], possibleChildren}, node)
            }

            send (JoinLevel{parent[lowestLatencyPeer], possibleChildren}, parent[lowestLatencyPeer])
            return
        }

        if myLatencies[parent[lowestLatencyPeer]] < myLatencies[lowestLatencyPeer] {
            // Join level as child, as i have better latency to the parent of this level vs the peer with lowest latency in this level
            send (JoinLevel{}, parent[lowestLatencyPeer])
            return
        } else {
            // explore the lowest latency nodes' children, because i have lower latency to him vs its parent

            if children.isEmpty() {
                send (JoinLevel{lowestLatencyPeer, []}, lowestLatencyPeer)
                return
            }

            currLevelPeers = children[lowestLatencyPeer]
            currJoinLevel += 1
            currLevelPeersDone = []
            for peer in currLevelPeers{
                send(Join{}, node)
            }
            return
        }
    }


upon receive(JoinLevel{mParent, mChildren}, sender) : 
    if self == mParent {
        children.append(sender)
        for peerChild in mChildren {
            if children.contains(peerChild) {
                children.remove(peerChild)
            }
        }
        sendMessage(JoinLevelReply{true}, sender)
        return
    }

    if mChildren.contains(self) {
        parent = mParent
        sendMessage(JoinLevelReply{true}, sender)
        return
    }
}



upon receive(JoinLevelReply{accepted}, sender) : 
    if possibleChildren.contains(sender) {
        children.append(sender)
    }
    if possibleParent == sender {
        parent[self] = sender
    }
}
